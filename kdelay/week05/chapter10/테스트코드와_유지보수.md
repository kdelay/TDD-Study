# 테스트 코드와 유지보수
- 자동화 테스트 (CI/CD)
  - 지속적으로 코드를 통합하고 출시 가능한 상태로 만들고 배포하려면 새로 추가한 코드가 기존 기능을 망가뜨리지 않는지 확인할 수 있어야 한다.
  - TDD 테스트 코드가 CI/CD의 자동화 테스트로 사용되어 버그가 배포되는 것을 막아주고 소프트웨어 품질이 저하되는 것을 막아준다.

1. 변수나 필드를 사용해서 기댓값 표현하지 않기
```text
변수 사용 예시
assertEquals(date.getYear()+"년", dateStr);

-> 변경
assertEquals("2024년", dateStr);

필드 값 사용 예시
문제가 생기면 필드를 참조하고 비교하면서 테스트 코드를 이해해야 한다.
private List<Integer> answers = Arrays.asList(1, 2, 3, 4);
assertAll(
    () -> assertEquals(answers.get(0), savedAnswer.getAnswers().get(0))
);

-> 변경
실제 값 자체를 사용해서 코드 가독성이 좋아진다.
assertAll(
    () -> assertEquals(1, savedAnswer.getAnswers().get(0))
);
```
2. 두 개 이상을 검증하지 않기
3. 정확하게 일치하는 값으로 모의 객체 설정하지 않기
```text
"pw" 문자열에 대해서 true를 반환하도록 설정한 경우
"pwa" 문자열을 입력하면 false가 반환된다.

이 테스트의 문제점은 "pw", "pwa" 등 정확한 문자열을 검증한다는 것이다.
정확한 문자열이 아닌 약한 암호 조건에 충족하는지를(모두 소문자인 경우) 검증하는 것이 목적이다.
```
4. 과도하게 구현 검증하지 않기
```text
테스트 대상의 내부 구현을 검증하지 말자 (코드 유지보수에 도움 X)
단점: 구현을 조금만 변경해도 테스트가 깨질 가능성이 높아진다.
예시: 메서드가 하나씩 모두 호출됐는지 검증
```
5. 셋업을 이용해서 중복된 상황을 설정하지 않기
```text
@BeforeEach 를 통해 setUp 메서드를 사용하면 유지보수할 때 한 번 더 확인해야 하는 번거로움이 있다.
모든 테스트 메서드가 동일한 상황 코드를 공유하기 때문에 테스트가 깨지기 쉬운 구조가 된다. 
```
6. 통합 테스트에서 데이터 공유 주의하기
```text
예시: DB 데이터 초기화
- 모든 테스트가 같은 값을 사용하는 데이터: 예) 코드값 데이터
- 테스트 메서드에서만 필요한 데이터: 예) 중복 ID 검사를 위한 회원 데이터
```
7. 통합 테스트의 상황 설정을 위한 보조 클래스 사용하기
8. 실행 환경이 다르다고 실패하지 않기
9. 실행 시점이 다르다고 실패하지 않기
10. 랜덤하게 실패하지 않기
```text
랜덤 값 생성이 필요한 경우 생성자를 통해 값을 받도록 수정하거나
다른 객체에 위임하게 바꾼다. (랜덤 값을 위한 클래스 별도 생성)
```
11. 필요하지 않은 값은 설정하지 않기
12. 단위 테스트를 위한 객체 생성 보조 클래스
```text
테스트를 위한 객체 생성 클래스 (팩토리 클래스, 빌더 패턴...)
```
13. 조건부로 검증하지 않기
14. 통합 테스트는 필요하지 않은 범위까지 연동하지 않기
```text
@SpringBootTest를 사용하면 모든 스프링 빈을 초기화하므로 
JdbcTemplate를 이용해서 데이터를 연동하려면 @JdbcTest 를 사용해서 DB 연동과 관련된 설정만 초기화한다. 
```
15. 더 이상 쓸모 없는 테스트 코드